"""
Core Dependencies Module - Dependency Injection Factories.

This module provides FastAPI-compatible dependency injection factories
for authentication supervisors, service authentication, and other
shared dependencies. Uses @lru_cache for singleton guarantees.

Following FastAPI 2024 best practices for enterprise applications:
- Centralized dependency management
- Testable via dependency_overrides
- Type-safe with Annotated aliases
"""

import base64
import logging
import os
import secrets
from functools import lru_cache
from pathlib import Path
from typing import Annotated, Any

from fastapi import Depends

logger = logging.getLogger(__name__)


def _decode_session_key(raw_value: str | None) -> bytes | None:
    """Decode a base64/urlsafe base64 encoded session key (32+ bytes).

    Attempts both standard and URL-safe base64 decoding to handle
    keys generated by different tools (openssl, Python secrets, etc.).

    Keys must be at least 32 bytes; if longer, they are truncated to 32
    to match Fernet's requirement. This aligns with startup_checks.py
    which accepts >= min_bytes.

    Args:
        raw_value: Base64-encoded string, or None.

    Returns:
        32-byte key if decoding succeeds, None otherwise.

    Raises:
        No exceptions raised - returns None on any decode failure.
    """
    if not raw_value:
        return None
    raw_value = raw_value.strip()
    if not raw_value:
        return None
    padded = raw_value + "=" * (-len(raw_value) % 4)
    for decoder in (base64.urlsafe_b64decode, base64.b64decode):
        try:
            decoded = decoder(padded.encode("utf-8"))
            # Accept >= 32 bytes, truncate to exactly 32 for Fernet
            if len(decoded) >= 32:
                return decoded[:32]
        except Exception:
            continue
    logger.error("Failed to decode session key; expected 32+ byte base64 string")
    return None


@lru_cache
def get_app_instance_dir() -> Path:
    """Get the application instance directory for persistent storage.

    Creates the directory if it doesn't exist. Falls back to ./instance
    if the configured path is not writable (e.g., local development).

    Returns:
        Path: Writable directory for application data (users.db, etc.).
    """
    app_instance_dir = Path(os.getenv("APP_INSTANCE_DIR", "/app/instance"))
    try:
        app_instance_dir.mkdir(parents=True, exist_ok=True)
        return app_instance_dir
    except Exception as exc:
        logger.warning(
            "Failed to create APP_INSTANCE_DIR %s: %s. Falling back to ./instance",
            app_instance_dir,
            exc,
        )
        fallback = Path("instance")
        fallback.mkdir(parents=True, exist_ok=True)
        return fallback


@lru_cache
def get_session_key() -> bytes:
    """Load or generate session encryption key.

    Attempts to load from Docker secrets first, then environment variables,
    finally generating an ephemeral key if neither is available.

    Returns:
        bytes: 32-byte session encryption key.

    Note:
        Ephemeral keys mean sessions are lost on restart. For production,
        always mount /run/secrets/session_key or set SESSION_KEY_B64.
    """
    from shared.security.secrets_manager import get_secret

    # Try Docker secrets first
    raw_secret = get_secret("session_key")
    session_key_bytes = _decode_session_key(raw_secret)
    if session_key_bytes:
        logger.info("✅ Loaded session encryption key from Docker secrets")
        return session_key_bytes

    # Try environment variables
    env_secret = os.getenv("SESSION_KEY_B64") or os.getenv("SESSION_KEY")
    session_key_bytes = _decode_session_key(env_secret)
    if session_key_bytes:
        logger.info("✅ Loaded session encryption key from environment")
        return session_key_bytes

    # Generate ephemeral key as fallback
    logger.warning("Session key not found; generating ephemeral key (sessions reset on restart)")
    return secrets.token_bytes(32)


@lru_cache
def get_auth_manager():
    """Factory for AuthManager singleton.

    Initializes the authentication manager with session key from secrets
    and configures the users database path.

    Returns:
        AuthManager: Configured authentication manager instance.

    Raises:
        RuntimeError: If auth module failed to import (fail-closed security).

    Example:
        >>> auth = get_auth_manager()
        >>> session = auth.validate_session(token)
    """
    try:
        from src.auth.auth_manager import AuthManager, init_auth_manager
    except ImportError as e:
        raise RuntimeError(
            f"SECURITY: AuthManager failed to import: {e}. Cannot start API Gateway without authentication."
        ) from e

    from shared.security.secrets_manager import get_secret

    session_key = get_session_key()
    users_db_key = get_secret("users_db_key")
    instance_dir = get_app_instance_dir()

    auth_manager = init_auth_manager(
        secret_key=session_key,
        db_path=str(instance_dir / "users.db"),
        db_encryption_key=users_db_key,
    )
    logger.info("Auth manager initialized via dependency injection")
    return auth_manager


@lru_cache
def get_service_auth():
    """Factory for ServiceAuth singleton for inter-service JWT authentication.

    Loads JWT keys from secrets and initializes service authentication
    for gateway-to-service communication.

    Returns:
        ServiceAuth: Configured service authentication instance.

    Raises:
        RuntimeError: If service auth fails to initialize (fail-closed).

    Example:
        >>> svc_auth = get_service_auth()
        >>> headers = svc_auth.get_auth_headers(expires_in=60)
    """
    from shared.security.service_auth import (
        get_service_auth as _get_svc_auth,
        load_service_jwt_keys,
    )

    try:
        jwt_keys = load_service_jwt_keys("gateway")
        service_auth = _get_svc_auth(service_id="gateway", service_secret=jwt_keys)
        logger.info("✅ JWT service auth initialized for gateway (keys=%s)", len(jwt_keys))
        return service_auth
    except Exception as auth_err:
        raise RuntimeError(
            f"SECURITY: ServiceAuth required but failed to initialize: {auth_err}. Run: ./scripts/setup_secrets.sh"
        ) from auth_err


@lru_cache
def get_auth_service():
    """Factory for AuthService singleton.

    Provides a service-layer wrapper around AuthManager for clean
    dependency injection in route handlers.

    Returns:
        AuthService: Configured auth service instance.

    Example:
        @router.post("/login")
        async def login(auth: AuthServiceDep):
            result = auth.authenticate(username, password)
    """
    from services.auth_service import AuthService

    auth_manager = get_auth_manager()
    return AuthService(auth_manager)


@lru_cache
def get_settings():
    """Factory for Settings singleton.

    Returns:
        Settings: Application configuration from environment.
    """
    from config.settings import Settings

    return Settings()


# Type aliases for FastAPI dependency injection
AuthManagerDep = Annotated[Any, Depends(get_auth_manager)]
ServiceAuthDep = Annotated[Any, Depends(get_service_auth)]
AuthServiceDep = Annotated[Any, Depends(get_auth_service)]


def get_require_auth():
    """Get the require_auth dependency from auth module.

    Lazy import to avoid circular dependencies during startup.

    Returns:
        Callable: The require_auth FastAPI dependency.

    Raises:
        RuntimeError: If auth module is not available.
    """
    try:
        from src.auth.permissions import require_auth

        return require_auth
    except ImportError as e:
        raise RuntimeError(f"SECURITY: Auth permissions module failed to import: {e}") from e


# Job storage for async operations (personality analysis, streaming)
# These are in-memory and reset on restart - consider Redis for persistence
personality_jobs: dict[str, dict[str, Any]] = {}
analysis_jobs: dict[str, dict[str, Any]] = {}
